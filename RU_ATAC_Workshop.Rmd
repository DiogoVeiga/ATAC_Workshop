---
title: "Analysis of ATAC-seq data in R and Bioconductor"
date: "`r Sys.Date()`"
author: "Thomas Carroll"
output:
  rmdformats::html_clean:
    highlight: pygments
---


```{r knitr_init, echo=FALSE, cache=FALSE}
library(knitr)
library(rmdformats)

## Global options
options(max.print="75")
opts_chunk$set(echo=FALSE,
	             cache=TRUE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=75)
```


## ATAC-seq, MNAse-seq and DNAse-seq


![ATAC,MNAse,DNAse](https://www.the-scientist.com/January2016/LT2_2.jpg)

* DNAse-seq - Enzymatic digestion to extract signal from open chromatin around transcription factor binding sites.

* MNAse-seq - Enzymatic digestion to extract signal repesenting nucleosome positioning.

* ATAC-seq - Uses transposases and offers a method to simultaneously extract signal from transcription factors binding sites and nucleosome positions from a single sample.


# Working with ATAC-seq data in R/Bioconductor


## Introduction

In this workshop we will look at some of the basics of ATAC-seq analysis in R using publically available data.

We will look at the alignment, post-alignment processing, plotting of ATAC-seq data over TSSs and motif occurrences, peak calling for nucleosome free regions and differential ATAC-seq signal.

### Covering today.

* Aligning ATAC-seq data.

* Plotting fragment lengths from ATAC-seq

* Creation of nucleosome free signal tracks.

* Peak calling for nucleosome free regions.

* Annotation and functional enrichment analysis of ATAC-seq.

* Differential nucleosome free regions from ATAC-seq data.

### The Sequencing Data.

In this workshop we will make use of three sets of published data.

The first dataset is from original ATAC-seq paper.

Transposition of native chromatin for multimodal regulatory analysis and personal epigenomics
Jason D. Buenrostro, Paul G. Giresi, Lisa C. Zaba, Howard Y. Chang, and William J. Greenleaf

In particular, we will make use of the ATACseq_50k_Rep2 sample GEO - GSM1155958 
Data can be retrieved in fastq format from ENA  

* SAMN02192806 - [here](https://www.ebi.ac.uk/ena/data/view/SAMN02192806)


For the second dataset we take ATAC-seq generated by Bing Ren at UCSD as part of the Encode consortium. 
Links to data and sample information are included in list below.

* Liver day 12 - [ENCSR302LIV](https://www.encodeproject.org/experiments/ENCSR302LIV/)

* Kidney day 15 - [ENCSR023QZX](https://www.encodeproject.org/experiments/ENCSR023QZX/)

* Hindbrain day 12 - [ENCSR088UYE](https://www.encodeproject.org/experiments/ENCSR088UYE/)


Finally I have processed some of the data from Christina Leslie' lab at MSKCC exactly as described in this workshop so we can review some of the characteristics of ATAC-seq data alongside the same data processed by Encode's pipeline.

The raw data and processed BAM file is available from Encodes portal

* T-Reg - [ENCSR724UJS](https://www.encodeproject.org/experiments/ENCSR724UJS/)


### The Reference Data

For ATAC-seq analysis we will require a few pieces of reference data. 

This includes-

* Reference genome in fasta format - [IGenomes](https://support.illumina.com/sequencing/sequencing_software/igenome.html) provides reference genomes for major organims. If you want the exact reference i use here you can [download from here](https://s3.amazonaws.com/rubioinformatics/hg19_Genome.fa)

* Gene models - We will retrieve these from TxDb Bioconductor annotation packages.

* Blacklists - Artefact regions specific to genomes. These can be found in [Encode portal here](https://www.encodeproject.org/annotations/ENCSR636HFF/)

### The Tools.


In this workshop we will concentrate on using R and Bioconductor to process your data.

Bioconductor has many packages to handle sequencing data including BAM files, BED files, bigWigs and Fasta files. Some of these tools may require large memory or care to process data in chunks. 
We process full size ATAC-seq data routinely in R but for some examples in this practical we will use just one chromosome to save time.

### Required R packages and versions.

We will need the latest version of R v(>=3.4) and Bioconductor (v3.6) with the following packages.

```{r packages, echo=TRUE,eval=FALSE,cache=FALSE}

# install.packages(knitr)

# install.packages(rmdformats)

# install.packages(dplyr)

# install.packages(DT)

# install.packages(tidyr)

# install.packages(ggplot2)

# install.packages(magrittr)

# install.packages(devtools)

# 
# source("https://bioconductor.org/biocLite.R")
# 

# ## Needed for mac and Linux only
# biocLite(Rsubread)
# ##
# 

# biocLite(Rsamtools)

# biocLite(GenomicAlignments)

# biocLite(TxDb.Hsapiens.UCSC.hg19.knownGene)

# biocLite(soGGi)

# biocLite(rtracklayer)

# biocLite(ChIPQC)

# biocLite(ChIPseeker)

# biocLite(rGREAT)

# biocLite(limma)

# biocLite(DESeq2)

# biocLite(TxDb.Mmusculus.UCSC.mm10.knownGene)

# biocLite(tracktables)

# biocLite(clusterProfiler)

# biocLite(org.Mm.eg.db)

# biocLite(MotifDb)

# biocLite(Biostrings)

# biocLite(BSgenome.Hsapiens.UCSC.hg19)
# 

# # Finally we need development version of soGGi (named here 1.10.4) 
# # not version on Bioconductor (1.10.0)
# devtools::install_github("ThomasCarroll/soGGi")

```


### IGV genome browser

We will also make use of IGV genome browser to review some results.

IGV is available from Broad [here](https://software.broadinstitute.org/software/igv/download).

### Processed Data in workshop 

We start with public sequencing data in links below and use reference data in Bioconductor and/or IGenomes.

We do not run to all the steps together today so i include processed data from various points in analysis at links below

**Essentials**

BAM file and BAI index from our alignment/sorting/indexing.

* [SAMN02192806 - Greenleaf BAM](https://s3.amazonaws.com/rubioinformatics/ATAC_Workshop/ATAC_Data/ATAC_BAM/Sorted_ATAC_50K_2.bam) - Full BAM file for Greenleaf example produced following in our Rsubread alignment, sorting and indexing.  

* [SAMN02192806 - Greenleaf BAI index](https://s3.amazonaws.com/rubioinformatics/ATAC_Workshop/ATAC_Data/ATAC_BAM/Sorted_ATAC_50K_2.bam.bai) - BAI index file for BAM in Greenleaf example produced following in our alignment, sorting and indexing. 

Small BAM, peak calls and directory structure.

* [ATAC_Workshop_Essential.zip](https://s3.amazonaws.com/rubioinformatics/ATAC_Workshop_Essential.zip) - Require additional workshop files and directory structure.

Once you have downloaded the above and unzipped **ATAC_Workshop.zip**, you should move the **Sorted_ATAC_50K_2.bam** and **Sorted_ATAC_50K_2.bam.bai** file into **ATAC_Workshop/ATAC_Data/ATAC_BAM/**

You should also copy the **RU_ATAC_Workshop.Rmd** to **ATAC_Workshop/** directory and open then to make sure all relative paths are correct. 

**Not essential**

Same as above but with BAMs for counting as well as small BAM, peak calls and directory structure.

* [ATAC_Workshop.zip](https://s3.amazonaws.com/rubioinformatics/ATAC_Workshop.zip)  - Additional workshop files and directory structure.

Bigwigs for IGV.

* [Bigwigs](https://s3.amazonaws.com/rubioinformatics/ATAC_bigWigs.zip) - BigWigs to review in IGV. 


## Greenleaf dataset fastq to BAM processing.

In this section we will work alittle with the Greenleaf dataset. 
We will process one sample of the Greenleaf data from fastq to BAM to allow us to review some of the features of ATAC-seq data and to create some processed files for review and further analysis.


### Creating a reference genome

The IGenomes repositories allow us to retrieve a consistent set of reference annotation for our genome of choice.

Here i have renamed the Fasta to something more meaningful in isolation -- **hg19_Genome.fa**.

We will use the Rsubread package to align our ATAC-seq data so first we must build an appropriate index from our Fasta for the Rsubread aligner.

**This takes awhile so run this after workshop if interested**

**Takes ~ 30 minutes on 3.1 GHz Intel Core i7 Mac pro**
```{r processData_BuildIndex, echo=TRUE,eval=FALSE,cache=FALSE}
library(Rsubread)

genome <- "ATAC_Data/ATAC_Reference/hg19_Genome.fa"
indexForSubread <- gsub("\\.fa$","",genome)

buildindex(indexForSubread,genome,indexSplit=FALSE)

```

### Aligning Sequence Reads to the Genome.

Now we have a reference genome, we can align our paired-end ATAC-seq reads using Rsubread.

Here we can use a standard alignment for DNA but we increase the maximum allowed fragment length to capture long fragments representing poly-nucleosome signal. 

The maximum allowed fragment length set here is based on parameters used within Greenleaf study.

**This takes awhile so run this after workshop if interested**

**Takes ~ 50 minutes on 3.1 GHz Intel Core i7 Mac pro**

```{r processData_align, echo=TRUE,eval=FALSE,cache=FALSE}
read1 <- "ATAC_Data/ATAC_FQs/SRR891269_1.fastq.gz"
read2 <- "ATAC_Data/ATAC_FQs/SRR891269_2.fastq.gz"
outBAM <- "ATAC_50K_2.bam"

align(indexForSubread,
      readfile1=read1,readfile2=read2,
      output_file = outBAM,
      nthreads=2,type=1,
      unique=TRUE,maxFragLength = 2000)

```

### Sorting and Indexing

Following alignment we would want to sort and index our BAM file for use with external tool.

First we sort our aligned data by sequence order (not Read Name here).

We then index our file allowing for rapid access of particular genomic locations by other programs (e.g IGV, Samtools) and by R/Bioconductor packaes we will use.

**This takes awhile so run this after workshop if interested**

**Takes ~ 15 minutes on 3.1 GHz Intel Core i7 Mac pro**

```{r processData_indexAndSort, echo=TRUE,eval=FALSE,cache=FALSE}
library(Rsamtools)
sortedBAM <- file.path(dirname(outBAM),
                       paste0("Sorted_",basename(outBAM))
                       )

sortBam(outBAM,gsub("\\.bam","",basename(sortedBAM)))
indexBam(sortedBAM)
```

**So around ~ 1hr 30 minutes in total to get to here.**

```{r processData_setBAM, echo=TRUE,eval=TRUE,cache=TRUE,include=TRUE}
sortedBAM <- "ATAC_Data/ATAC_BAM/Sorted_ATAC_50K_2.bam"
```


### Number of mapped reads

We can now check the mapping rate to make sure we do have any problems with the aligmnent.
Here we use Rsubread's propmapped to give us number of mapped, unmapped and mapping percentage

**This takes awhile so run this after workshop if interested**

**Takes ~ 15 minutes on 3.1 GHz Intel Core i7 Mac pro**
```{r mappingStats, echo=TRUE,eval=FALSE,cache=TRUE,dependson="processData_setBAM"}
library(Rsubread)
pmapped <- propmapped(sortedBAM)
pmapped
```

```{r mappingStatsResultsFromPropMapped, echo=FALSE,eval=TRUE,cache=TRUE,dependson="processData_setBAM"}
dfS <- data.frame(Sample="ATAC_Data/ATAC_BAM/Sorted_ATAC_50K_2.bam",NumTotal=56598621,NumMapped=55521254,PropMapped=0.980965)
dfS
```
### Distribution of mapped reads

We can see we have a great mapping rate but we would also want to check the distribution of mapped reads across chromosomes.

ATAC-seq is known have high signal on the mitochondrial chromosomes and so we can check for that here.

In this example, we see an extreme case where the mapping rate to mitochondrial genome is extremely high.

```{r quickMappingStatsPerChromosome, echo=TRUE,eval=TRUE,cache=TRUE,dependson="processData_setBAM"}
library(Rsamtools)
library(ggplot2)
library(magrittr)

idxstatsBam(sortedBAM) %>%
  ggplot(aes(seqnames,mapped,fill=seqnames))+geom_bar(stat="identity")+coord_flip()
```

Lets see if it is always that bad. 

So we take some data from Bing Ren's lab (processed from fastq) and from our neighbour's at MSKCC and see how it looks there. 

We will also take some ChIP-seq to identify a potential similar trend there.

![Distribution of reads](ATAC_Data/images/example_MappingDistPlot.png)

## Greenleaf dataset post-alignment processing.

Now we have the processed the ATAC-seq paired-end data we can start to work with alignments.

We will identify the expected fragment length distribution and split our data into that representing nucleosome free and mono-nucleosomes.

### Reading in mapped reads

We will read our newly aligned data using the GenomicAlignments package. 

Here we only read properly paired, uniquely mapped reads mapping to Chromosome 20. We also retrieve the read name, mapq scores and importantly the insert sizes. 

```{r processData_readingInData, echo=TRUE,eval=TRUE,cache=TRUE,dependson="processData_setBAM"}
library(GenomicAlignments)

atacReads <- readGAlignmentPairs(sortedBAM,
                                 param=ScanBamParam(mapqFilter=1, 
                                                    flag=scanBamFlag(isPaired = TRUE, 
                                                                     isProperPair =TRUE), 
                                                    what=c("qname","mapq","isize"), which=GRanges("chr20", IRanges(1,63025520))))
#length(atacReads)
atacReads

```


### Retrieving insert sizes

Now we have read in the paired aligned data into R, we can retreive the insert sizes from the elementMetadata attached to reads.

Since properly paired reads will have same insert size length we extract insert sizes from read1.

```{r processData_extractingRead1, echo=TRUE,eval=TRUE,cache=TRUE,dependson="processData_readingInData"}

atacReads_read1 <- GenomicAlignments::first(atacReads)
insertSizes <- abs(elementMetadata(atacReads_read1)$isize)
head(insertSizes)
```

### Plotting insert sizes

ATAC-seq should represent a mix of fragment lengths corresponding to nucleosome free, mononucleosome and poly-nucleosome fractions.

We can use the newly acquired insert lengths for chromosome 20 to plot the distribution of all fragment lengths.


```{r processData_plottingFragmentLengths, echo=TRUE,eval=TRUE,cache=TRUE,dependson="processData_extractingRead1"}
library(magrittr)
library(dplyr)
library(ggplot2)
fragLenPlot <- table(insertSizes) %>%
  data.frame %>% 
  rename(InsertSize=insertSizes,Count=Freq) %>% 
  mutate(InsertSize=as.numeric(as.vector(InsertSize)),Count=as.numeric(as.vector(Count))) %>% 
  ggplot(aes(x=InsertSize,y=Count))+geom_line()

fragLenPlot+theme_bw()
fragLenPlot + scale_y_continuous(trans='log2')+theme_bw()
```

### Plotting insert sizes with Greenleaf open, mono- and di-nucleosome profiles

This looks very similar to the image from the Greenleaf paper.

We can now annotate our nucleosome free (< 100bp), mono-nucleosome (180bp-247bp) and di-nucleosome (315-437) as in the Greenleaf study.

```{r processData_plottingFragmentLengths2, echo=TRUE,eval=TRUE,cache=TRUE,dependson="processData_plottingFragmentLengths"}
fragLenPlot+geom_vline(xintercept = c(180,247),colour="red")+geom_vline(xintercept = c(315,437),colour="darkblue")+geom_vline(xintercept = c(100),colour="darkgreen")+theme_bw()

fragLenPlot+ scale_y_continuous(trans='log2')+geom_vline(xintercept = c(180,247),colour="red")+geom_vline(xintercept = c(315,437),colour="darkblue")+geom_vline(xintercept = c(100),colour="darkgreen")+theme_bw()

```


Again we can make a quick comparison with some other datasets.

![Fragment length distributions](ATAC_Data/images/Example_FLdist.png)

![Fragment length distributions](ATAC_Data/images/FL_dist_lohScale.png)

### Plotting ATAC-seq signal of TSSs (Retrieving TSSs regions)

From the fragment length plots shown above it would seem we have evidence of data coming both from nucleosome occupied and nucleosome free regions.

We expect nucleosome free regions to be present at TSSs of active genes and nucleosome signal to be be more enriched in regions surrounding the TSS

To investigate this we will produce a meta-TSS plot of average signal of the different fragment length signals across TSSs.

First then we need a set of TSS positions which we can retrieve from the gene models in the **TxDb.Hsapiens.UCSC.hg19.knownGene** package.


```{r processData_plottingFragmentLengthsAcrossTSS, echo=TRUE,eval=TRUE,cache=TRUE}
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
TSSs <- resize(genes(TxDb.Hsapiens.UCSC.hg19.knownGene),fix="start",1)
TSSs
```

### Plotting ATAC-seq signal of TSSs (Creating open, mono- and di-nucleosome signal profiles)

Now we have all the TSS positions across the genome we can use the soGGi package to make plots of average signal across TSSs for different fragment length ranges.

**This takes awhile so run this after workshop if interested**

**Takes ~ 20 minutes on 3.1 GHz Intel Core i7 Mac pro**

```{r processData_retrievingTSSData, echo=TRUE,eval=FALSE,cache=TRUE}
library(soGGi)

# Nucleosome free
nucFree <- regionPlot(bamFile = sortedBAM,
                        testRanges = TSSs,
                        style = "point",
                        format="bam",
                        paired=TRUE,
                        minFragmentLength = 0,maxFragmentLength = 100,forceFragment = 50)

# Mononucleosome
monoNuc <- regionPlot(bamFile = sortedBAM,
                        testRanges = TSSs,
                        style = "point",
                        format="bam",
                        paired=TRUE,
                        minFragmentLength = 180,maxFragmentLength = 240,forceFragment = 80)

# Dinucleosome
diNuc <- regionPlot(bamFile = sortedBAM,
                        testRanges = TSSs,
                        style = "point",
                        format="bam",
                        paired=TRUE,
                        minFragmentLength = 315,maxFragmentLength = 437,forceFragment = 160)

# nucFree_gL <- nucFree
# monoNuc_gL <- monoNuc
# diNuc_gL <- diNuc
# 
# save(monoNuc_gL,nucFree_gL,diNuc_gL,file="ATAC_Data/ATAC_RData/gL_soGGiResults.RData")

```

### Plotting ATAC-seq signal of TSSs (Plotting open, mono- and di-nucleosome signal profiles)

From the meta-TSS plots of different fragment lengths we can see the expected distribution of signal.

Nucleosome free fragments having a peak around the the TSS and nucleosome occupied signal peaking around the TSS with a strong peak at the +1 nucleosome.

```{r processData_plotTSSData, echo=TRUE,eval=TRUE,cache=TRUE}
library(soGGi)
load(file="ATAC_Data/ATAC_RData/gL_soGGiResults.RData")
plotRegion(nucFree_gL,outliers=0.01)
plotRegion(monoNuc_gL,outliers=0.01)
plotRegion(diNuc_gL,outliers=0.01)
```


Again we can look at some of other datasets for mono-nucleosomes to get and idea what we may see.

![Mononnucleosome plots](ATAC_Data/images/Mono_nuc_ExternalData.png)

### Subsetting ATAC-seq reads files by insert sizes.

We may wish to divide our aligned reads into reads representing nucleosome free and nucleosome occupied. 

Here we create BAM files for the reads representing nucleosome free, mono and di nucleosome by using insert sizes to filtering read.

```{r processData_createOpenRegionBAM, echo=TRUE,eval=TRUE,cache=TRUE,dependson=c("processData_extractingRead1","processData_readingInData")}
atacReads_Open <- atacReads[insertSizes < 100,]
atacReads_MonoNuc <- atacReads[insertSizes > 160 & insertSizes < 240,]
atacReads_diNuc <- atacReads[insertSizes > 315 & insertSizes < 437,]
```

### Creating BAM files split by insert sizes.

The resulting reads can be written back to BAM files for use in other parts of our analysis or for visualisation in programs such as IGV by functions in the rtracklayer package.


```{r processData_createOpenRegionBAM_2, echo=TRUE,eval=TRUE,cache=TRUE,dependson="processData_createOpenRegionBAM"}
openRegionBam <- gsub("\\.bam","_openRegions\\.bam",sortedBAM)
monoNucBam <- gsub("\\.bam","_monoNuc\\.bam",sortedBAM)
diNucBam <- gsub("\\.bam","_diNuc\\.bam",sortedBAM)

library(rtracklayer)
export(atacReads_Open,openRegionBam,format = "bam")
export(atacReads_MonoNuc,monoNucBam,format = "bam")
#export(atacReads_Open,diNucBam,format = "bam")
```

### Creating an open region bigWig.

We can make it significantly quicker to review the pile-up of ATAC-seq signal in a genome browser by creating a bigWig file.

Additional normalisation to total mapped reads and duplicate removal could be applied at this point.

```{r processData_createOpenRegionBigWig_2, echo=TRUE,eval=TRUE,cache=TRUE,dependson="processData_createOpenRegionBAM"}
openRegionBigWig <- gsub("\\.bam","_openRegions\\.bw",sortedBAM)
openRegionRPMBigWig <- gsub("\\.bam","_openRegionsRPM\\.bw",sortedBAM)
atacFragments_Open <- granges(atacReads_Open)
export.bw(coverage(atacFragments_Open),openRegionBigWig)
```

![bigWig in IGV](ATAC_Data/images/bigwigImage.png)

# Greenleaf dataset - Finding Open Regions.

A common goal in ATAC-seq is to identify open chromatin regions/nucleosome free regions. 

For the remainder of the workshop we will look at analysing the nucleosome free portions of the our ATAC-seq data.

## Peak calling for nucleosome free regions.

As we discussed, the reads with insert sizes less than 100bp represent fragments coming from open chromatin and around transcription factors bound to the DNA.

There are many methods available to call nucleosome free regions from ATAC-seq data with many borrowed from ChIP-seq analysis.


### Peak calling using MACS2

One very popular and standard peak caller for ATAC-seq is MAC2.

MACS2 is well established for identifying punctate peaks found in ChIP-seq data from transcription factors.

MACS2 website can be found [here]() with information on parameters and use cases.


### Single end peak calling.

With single end sequencing from ATAC-seq we do not know how long the fragments are.

To identify open regions therefore requires some different parameters for MACS2 peak calling.

One strategy employed is to shift read 5' ends by -100 and then extend from this by 200bp. Considering the expected size of our nucleosome free fragments this should provide a pile-up over nucelosome regions suitable for MACS2 window size. 

```{r MACS2_singlePeakCallOpen, engine="bash", echo=TRUE,eval=FALSE,cache=TRUE}
MACS2 callpeak -t singleEnd.bam --nomodel --shift -100 --extsize 200 --format BAM -g MyGenome
```

Alternatively for the nucleosome occupied data we can adjust shift and extension to centre the signal on nucleosome centres (nucleosomes wrapped in 147bp of DNA). 

```{r MACS2_singlePeakCallmononuc, engine="bash", echo=TRUE,eval=FALSE,cache=TRUE}
MACS2 callpeak -t singleEnd.bam --nomodel --shift 37 --extsize 73 --format BAM -g MyGenome
```

### Paired end peak calling.

If we have sequenced paired-end data then we do know the fragment lengths and can provide pre-filter BAM files to MACS2.

We have to simply tell MACS2 that the data is paired using the format argument.

By default MACS2 will guess it is single end BAM.

```{r MACS2_pairedPeakCall, engine="bash", echo=TRUE,eval=FALSE,cache=TRUE}
MACS2 callpeak -t pairedEnd.bam -f BAMPE --outdir path/to/output/ --name pairedEndPeakName -g MyGenome
```

```{r MACS2_pairedPeakCall_Actual, engine="bash", echo=TRUE,eval=FALSE,cache=TRUE,tidy=TRUE,include=FALSE}
MACS2 callpeak  -t ATAC_Data/ATAC_BAMs/Sorted_ATAC_50K_2_openRegions.bam 
                --outdir ATAC_Data/ATAC_Peaks/ATAC_50K_2_openRegions 
                --name ATAC_50K_2_openRegions 
                -f BAMPE -g hs
```


Following peak calling we would get 3 files.

* Name.narrowPeak -- Narrow peak format suitable for IGV and further analysis

* Name_peaks.xls -- Peak table suitable for review in excel.(not actually a xls but a tsv)

* summits.bed -- Summit positions for peaks useful for finding motifs and plotting

## QC for low quality, duplicates and signal distribution.

Before we remove any data we can get a quick assessment of our reads in peaks, duplication rate, low quality reads and reads in artefact regions from ChIPQC.

```{r processData_callQC,messages=FALSE,warning=FALSE, echo=TRUE,eval=TRUE,cache=TRUE,dependson="readinPeakCalling"}
library(ChIPQC)
library(rtracklayer)
library(DT)
library(dplyr)
library(tidyr)

blkList <- import.bed("ATAC_Data/ATAC_blacklists/ENCFF001TDO.bed.gz")
openRegionPeaks <- "ATAC_Data/ATAC_Peaks/Sorted_ATAC_50K_2_Small_Paired_peaks.narrowPeak"

qcRes <- ChIPQCsample("ATAC_Data/ATAC_BAM/Sorted_ATAC_50K_2_openRegions.bam",peaks = openRegionPeaks,annotation ="hg19",chromosomes = "chr20",blacklist = blkList,verboseT = FALSE)
  
  
  QCmetrics(qcRes) %>% t %>%  data.frame %>%  dplyr:::select(Reads,starts_with(c("Filt")),starts_with(c("RiP")),starts_with(c("RiBL"))) %>% datatable(rownames = NULL)
  flagtagcounts(qcRes) %>% t %>%  data.frame  %>% mutate(Dup_Percent=(DuplicateByChIPQC/Mapped)*100) %>% dplyr:::select(Mapped,Dup_Percent) %>% datatable(rownames = NULL)
  
```

## Blacklisted Regions

A potential confounder of analysis and a source of noise in ATAC-seq (and ChIPseq/DNAseq etc) are high signal arteact regions within the genome. 

Such regions have been previously defined for many model organisms and are available from the encode portal [here](https://www.encodeproject.org/annotations/ENCSR636HFF/).

![blacklist in IGV](ATAC_Data/images/blkList1.png)
![blacklist in IGV](ATAC_Data/images/blkList2.png)



##  Remove blacklisted peaks 

Since blacklisted regions may confound our analysis we remove any peaks which have been called there. 

Removing blacklists too early can hide some of the qc issues in your data. The **blacklist** should always be considered in your analysis and recommended to removed data from these regions once QC is considered.

```{r processData_filterBLKlist, echo=TRUE,eval=TRUE,cache=TRUE,dependson="processData_callQC"}
MacsCalls_chr20 <- granges(qcRes[seqnames(qcRes) %in% "chr20"])

data.frame(Blacklisted=sum(MacsCalls_chr20 %over% blkList),Not_Blacklisted=sum(!MacsCalls_chr20 %over% blkList))
MacsCalls_chr20_filtered <- MacsCalls_chr20[!MacsCalls_chr20 %over% blkList]
```


# Greenleaf dataset - Annotating Open Regions.

It is often of interest to associate identified open/nucleosome free regions to genomic features such as genes and enhancers.

Once annotated to genes or enhancers' genes, we can start to associate ATAC-seq data to characteristics of these genes. (functional annotation, expression changes, other epigenetic states)

### Annotating peaks to genes.

A simple approach to annotating nucleosome free region to genes is to associate regions to their closest gene or within a window around a genes transcriptional start site.

We can use the chipseeker library to identify genes closest to our regions and to give us simple summaries and visualisations of this annotation.

We use the gene models from TxDb.Hsapiens.UCSC.hg19.knownGene and supply this to ChIPseeker packages annotatePeak function.

ChIPseeker's csAnno object will then show breakdown of percentages of peaks in genomic regions.

```{r processData_annotatePeak, echo=TRUE,eval=TRUE,cache=TRUE,dependson=c("processData_filterBLKlist","processData_plottingFragmentLengthsAcrossTSS")}
library(ChIPseeker)
MacsCalls_chr20_filteredAnno <-  annotatePeak(MacsCalls_chr20_filtered,
                                              TxDb = TxDb.Hsapiens.UCSC.hg19.knownGene)
MacsCalls_chr20_filteredAnno
```

### Displaying annotation distribution

As well as showing us a table of the annotation distribution we can visualise this using the plotAnnoPie and plotAnnoBar functions.

```{r processData_Pie, echo=TRUE,eval=TRUE,cache=TRUE,dependson="processData_annotatePeak"}

plotAnnoPie(MacsCalls_chr20_filteredAnno)
plotAnnoBar(MacsCalls_chr20_filteredAnno)
```

### Visualising overlaps between genomic regions.

It is important to note that ChIPseeker is making some critical choices for you here. An important decision is the order of preference in annotating our peaks when they fall in multiple gene regions .. ie. (5'UTR and promoter).

The overlap between annotation can be seen by way of an upset plot.

```{r processData_UpsetPlot,echo=TRUE,eval=TRUE,cache=TRUE,dependson="processData_annotatePeak"}
upsetplot(MacsCalls_chr20_filteredAnno)
```



### Retrieving annotated Nucleosome-free regions.

With this information we can then subset our peaks/nuc free regions to those only landing in TSS regions (+/- 500)

```{r processData_annotated, echo=TRUE,eval=TRUE,cache=TRUE,dependson="processData_annotatePeak"}
MacsGranges_Anno <- as.GRanges(MacsCalls_chr20_filteredAnno)
TSS_MacsGranges_Anno <- MacsGranges_Anno[abs(MacsGranges_Anno$distanceToTSS) < 500]
TSS_MacsGranges_Anno
```


### Functional Analysis of Nucleosome-free regions - 1.

Another common step to ATAC-seq analysis is to identify any functional enrichment in genes associated to nucleosome free regions.

One approach is to take the genes we identified from ChIPseeker as having nuclesome free regions and test these for functional enrichment using standard tools. 

Another approach which is well suited to ATAC-seq is that implemented in GREAT.

GREAT first defines potential regulatory regions for all genes and then then tests for enrichment accounting for total size of regulatory regions for a pathway/GO term/gene set.

GREAT is queried typically through its web portal [here](http://great.stanford.edu/public/html/) but we can take advantage of the r interface in rGREAT.

**rGREAT by default will limit our queries and so we may need to be patient. This can be adjusted in rGREAT options.**

We can submit our peak calls to GREAT using the submitGreatJob function and review available categories of results using availableCategories.

```{r processData_funAnalysise,echo=TRUE,eval=TRUE,cache=TRUE,dependson="processData_filterBLKlist"}
library(rGREAT)
seqlevelsStyle(MacsCalls_chr20_filtered) <- "UCSC"

great_Job <- submitGreatJob(MacsCalls_chr20_filtered, species = "hg19")
availableCategories(great_Job)
```

### Functional Analysis of Nucleosome-free regions - 2.

For this example we select the results tables for the GO category using getEnrichmentTables functions and then review the results for Biological processes.

```{r processData_funAnalysis2,echo=TRUE,eval=TRUE,cache=TRUE,dependson="processData_funAnalysis2"}
great_ResultTable = getEnrichmentTables(great_Job, category = "GO")
names(great_ResultTable)          
great_ResultTable[["GO Biological Process"]][1:4, ]
save(great_ResultTable,file="ATAC_Data/ATAC_RData/Great_Results.RData")
```

## Differential ATAC-seq

We have briefly reviewed the processing and initial analysis of one ATAC-seq sample using R.

In the next part we will look at how we can identify changes in open regions using R/Bioconductor.

Here we will take an approach akin that in Diffbind and reasonably esatablished in ATAC-seq analysis. 

First, We will define a set of non-redundant peaks present in at least 2 samples and use these to assess changes in nuc-free ATAC-seq signal using DESeq2.

## Identifying a set of non-redundant peaks.

![blacklist in IGV](ATAC_Data/images/fromChIPseqTalk.png)

Here we will use soGGi to produce merge our open regions from all samples into a set of non-redundant (no overlapping regions) open regions present in any sample.

```{r processData_consensus, echo=TRUE,eval=TRUE,cache=TRUE}
peaks <- dir("ATAC_Data/ATAC_Peaks_forCounting/",pattern="*.narrowPeak",full.names=TRUE)
myPeaks <- lapply(peaks,ChIPQC:::GetGRanges,simple=TRUE)

names(myPeaks) <- c("HindBrain_1","HindBrain_2","Kidney_1","Kidney_2","Liver_1","Liver_2")
Group <- factor(c("HindBrain","HindBrain","Kidney","Kidney","Liver","Liver"))
consensusToCount <- soGGi:::runConsensusRegions(GRangesList(myPeaks),"none")

blklist <- import.bed("ATAC_Data/ATAC_blacklists/ENCFF547MET.bed.gz")

consensusToCount <- consensusToCount[!consensusToCount %over% blklist & !seqnames(consensusToCount) %in% "chrM"]

consensusToCount
```

## Overlap of nucleosome free regions among replicates.

Now we have a set of non-redundant peaks we can review the correspondance between replicates by venn diagrams of peak overlaps.

Here we pass the overlap matrix generated by soGGi to limma's vennDiagram function.

```{r processData_consensus_Venns, echo=TRUE,eval=TRUE,cache=TRUE,dependson="processData_consensus"}
library(limma)

as.data.frame(elementMetadata(consensusToCount)) %>% dplyr::select(starts_with("Liver")) %>% 
  vennDiagram(main="Overlap for Liver open regions")

as.data.frame(elementMetadata(consensusToCount)) %>% dplyr::select(starts_with("Kidney")) %>% 
  vennDiagram(main="Overlap for Kidney open regions")

as.data.frame(elementMetadata(consensusToCount)) %>% dplyr::select(starts_with("HindBrain")) %>% 
  vennDiagram(main="Overlap for Hindbrain open regions")

```

## PCA of overlaps (occupancy analysis).

We can also Diffbind style PCA analysis (Occupancy analysis in Diffbind) of peak overlaps to get an overall view of correspondance between peak calls.

Here we pass the matrix of peak overlaps from soGGi to prcomp function and plot the results in ggplot2.

```{r processData_consensus_diffbindStylePCA, echo=TRUE,eval=TRUE,cache=TRUE,dependson="processData_consensus"}
library(tidyr)

myPlot <- as.data.frame(elementMetadata(consensusToCount)) %>% 
  dplyr::select(-consensusIDs) %>% 
  as.matrix %>% t %>% prcomp %>% .$x %>% data.frame %>% 
  mutate(Samples=rownames(.)) %>% 
  mutate(Group=gsub("_\\d","",Samples)) %>% 
  ggplot(aes(x=PC1,y=PC2,colour=Group))+geom_point(size=5)

myPlot
```

## Counting for differential ATAC-seq.


The presense or absense of a peak does not fully capture the changes in ATAC-seq signal observed in a genome broswer. Identifying changes of ATAC-seq signal within peaks will allow us to better capture ATAC-seq signal differences.

To do this we will borrow some methods from RNA-seq,  namely DESeq2, to evaluate changes in ATAC-seq signal between groups/tissues.

First we will filter our peaks in a manner similar to Diffbind, where we keep only peaks which are present in at least two replicates.


```{r processData_consensusCounting, echo=TRUE,eval=TRUE,cache=TRUE,dependson="processData_consensus"}
library(Rsubread)
occurrences <- elementMetadata(consensusToCount) %>% as.data.frame %>% dplyr::select(-consensusIDs) %>% rowSums

table(occurrences) %>% rev %>% cumsum

consensusToCount <- consensusToCount[occurrences >= 2,]

consensusToCount
```

Now we have to set of regions to count in we can use Rsubread to count paired reads landing in peaks.

**Note that Rsubread allows for maximum and minimum fragment lengths!**

**This takes awhile so run this after workshop if interested**

**Takes ~ 10 minutes on 3.1 GHz Intel Core i7 Mac pro**

```{r processData_consensusCounting2, echo=TRUE,eval=FALSE,cache=TRUE,dependson="processData_consensusCounting"}

bamsToCount <- dir("ATAC_Data/ATAC_BAM_forCounting/",full.names = TRUE,pattern = "*.\\.bam$")
#indexBam(bamsToCount)
regionsToCount <- data.frame(GeneID=paste("ID",seqnames(consensusToCount),start(consensusToCount),end(consensusToCount),sep="_"),
                             Chr=seqnames(consensusToCount),Start=start(consensusToCount),End=end(consensusToCount),Strand=strand(consensusToCount))
fcResults <- featureCounts(bamsToCount,annot.ext=regionsToCount,isPairedEnd = TRUE,countMultiMappingReads = FALSE,maxFragLength=100)
myCounts <- fcResults$counts
colnames(myCounts) <- c("HindBrain_1","HindBrain_2","Kidney_1","Kidney_2","Liver_1","Liver_2")
save(myCounts,file="ATAC_Data/ATAC_RData/countsFromATAC.RData")
```

## DESeq2 for differential ATAC-seq.

With our counts of fragments in nucleosome free regions we can now contruct a DESeq2 object and perform a PCA again but this time using signal within peaks, not just occurrence in regions. 

We pass the GRanges of regions we count to DESeqDataSetFromMatrix function so as to access these from DESeq2 later.

```{r processData_DEseq2_PCA, echo=TRUE,eval=TRUE,cache=TRUE}
library(DESeq2)
load("ATAC_Data/ATAC_RData/countsFromATAC.RData")
metaData <- data.frame(Group,row.names=colnames(myCounts))
atacDDS <- DESeqDataSetFromMatrix(myCounts,metaData,~Group,rowRanges=consensusToCount)
atacDDS <- DESeq(atacDDS)
atac_Rlog <- rlog(atacDDS)
plotPCA(atac_Rlog,intgroup="Group",ntop=nrow(atac_Rlog))
```

With the new DESeq2 object we can now test for any differences in ATAC-seq signal between groups.

In this example we look at differences between hindbrain and liver samples. 

We return a GRanges object here to allow us to perform some more GenomicRanges operations.

```{r processData_DEseq2_Results_ResultsTable, echo=TRUE,eval=TRUE,cache=TRUE,dependson="processData_DEseq2_PCA"}
library(DESeq2)
library(BSgenome.Mmusculus.UCSC.mm10)
library(tracktables)


LiverMinusHindbrain <- results(atacDDS,c("Group","Liver","HindBrain"),format="GRanges")
LiverMinusHindbrain <- LiverMinusHindbrain[order(LiverMinusHindbrain$pvalue)]
LiverMinusHindbrain
```

We can subset to only open regions within promoters and then create a table to review the results in IGV using makebedtable function in tracktables package. 

```{r processData_DEseq2_ResultsToTSSregions, echo=TRUE,eval=TRUE,cache=TRUE,dependson="processData_DEseq2_Results_ResultsTable"}

library(TxDb.Mmusculus.UCSC.mm10.knownGene)
toOverLap <- promoters(TxDb.Mmusculus.UCSC.mm10.knownGene,500,500)
LiverMinusHindbrain <- LiverMinusHindbrain[(!is.na(LiverMinusHindbrain$padj) & LiverMinusHindbrain$padj < 0.05) & LiverMinusHindbrain %over% toOverLap,]
#LiverMinusHindbrain <- LiverMinusHindbrain[!is.na(LiverMinusHindbrain$padj) & LiverMinusHindbrain$padj < 0.05,]
makebedtable(LiverMinusHindbrain,"LiverMinusHindbrain.html","ATAC_Data/")
```

## Annotation for differential ATAC-seq.

In the final part we can annotate our differential ATAC-seq regions to genes and then use gene information to test enrichment for GO sets.

Since we have subset regions to those within +/- 500bp of a TSS we can use a standard enrichment analysis at this point. Here we use clusterProfiler to identify enrichment

```{r processData_DEseq2_functionalEnrichmentAnalysis, echo=TRUE,eval=TRUE,cache=TRUE, dependson="processData_DEseq2_ResultsToTSSregions"}


library(clusterProfiler)
library(ChIPseeker)

anno_LiverMinusHindbrain <- annotatePeak(LiverMinusHindbrain,TxDb = TxDb.Mmusculus.UCSC.mm10.knownGene)


go1 <- enrichGO(as.data.frame(as.GRanges(anno_LiverMinusHindbrain)[as.GRanges(anno_LiverMinusHindbrain)$log2FoldChange > 0])$geneId,
                OrgDb = "org.Mm.eg.db",ont = "BP",maxGSSize = 5000)
go2 <- enrichGO(as.data.frame(as.GRanges(anno_LiverMinusHindbrain)[as.GRanges(anno_LiverMinusHindbrain)$log2FoldChange < 0])$geneId, 
                OrgDb = "org.Mm.eg.db",ont = "BP",maxGSSize = 5000)

head(go1,10) %>% dplyr::select(ID,Description,pvalue,p.adjust) %>% datatable(elementId = "goEle1")
head(go2,10) %>% dplyr::select(ID,Description,pvalue,p.adjust) %>% datatable(elementId = "goEle2")

```

## Export annotated, differential ATAC-seq.

Finally, we can write out the table of annotated differential ATAC-seq peaks to review in Excel or as bed files.


```{r processData_DEseq2_export, echo=TRUE,eval=FALSE,cache=TRUE}
  
anno_LiverMinusHindbrain_GRanges <- as.GRanges(anno_LiverMinusHindbrain)
anno_LiverMinusHindbrain_GRanges_Up <- anno_LiverMinusHindbrain[elementMetadata(anno_LiverMinusHindbrain)$log2FoldChange > 0]
anno_LiverMinusHindbrain_GRanges_Down <- anno_LiverMinusHindbrain[elementMetadata(anno_LiverMinusHindbrain)$log2FoldChange < 0]
export.bed(anno_LiverMinusHindbrain_GRanges_Up,"LiverMinusHindbrain_Up.bed")
export.bed(anno_LiverMinusHindbrain_GRanges_Down,"LiverMinusHindbrain_Down.bed")

anno_LiverMinusHindbrain_df <- as.data.frame(anno_LiverMinusHindbrain)
write.table(anno_LiverMinusHindbrain_df,"LiverMinusHindbrain.csv",quote=FALSE,row.names=FALSE,sep=",")

```


## Cutting sites from ATAC-seq data

ATAC-seq should generate shorter fragments (our nucleosome free regions) around smaller *protected* areas such as transcription factor binding sites.

We can therefore look for the pile-up of cut-sites around motifs of interest within different tissues/celltypes/samples.

To produce cut-sites from our BAM file we first resize our reads to 1bp and make the shift of 4/-5 bp depending on strand to adjust for expected shift from insertion of Tn5 transposase.

Here we will identify CTCF motifs passing an arbitary cut-off and then use soGGi to plot cut-sites around them

```{r processData_motifCuts, echo=TRUE,eval=TRUE,cache=TRUE,dependson="processData_createOpenRegionBAM_2"}

library(MotifDb)
library(Biostrings)
library(BSgenome.Hsapiens.UCSC.hg19)

CTCF <- query(MotifDb, c("CTCF"))
CTCF <- as.list(CTCF)
myRes <- matchPWM(CTCF[[1]],BSgenome.Hsapiens.UCSC.hg19[["chr20"]])
toCompare <- GRanges("chr20",ranges(myRes))

read1 <- first(atacReads_Open)
read2 <- second(atacReads_Open)
Firsts <- resize(granges(read1),fix="start",1)
First_Pos_toCut <- shift(granges(Firsts[strand(read1) == "+"]),
                                         4)
First_Neg_toCut <- shift(granges(Firsts[strand(read1) == "-"]),
                                         -5)


Seconds <- resize(granges(read2),fix="start",1)
Second_Pos_toCut <- shift(granges(Seconds[strand(read2) == "+"]),
                                4)
Second_Neg_toCut <- shift(granges(Seconds[strand(read2) == "-"]),
                                -5)
  
test_toCut <- c(First_Pos_toCut,
                First_Neg_toCut,
                Second_Pos_toCut,
                Second_Neg_toCut)
cutsCoverage <- coverage(test_toCut)
cutsCoverage20 <- cutsCoverage["chr20"]
CTCF_Cuts_open <- regionPlot(cutsCoverage20,
                         testRanges = toCompare,
                         style = "point",
                         format="rlelist",distanceAround = 500)
plotRegion(CTCF_Cuts_open,outliers = 0.001)+ggtitle("NucFree Cuts Centred on CTCF")

```
